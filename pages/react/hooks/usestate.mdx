---
title: useState
---

import useStateArray from '../../../examples/files/hooks/useStateArray.js'

# useState

<Author name="@msyleung" url="https://twitter.com/msyleung" />

The `useState` hook lets us "remember" a value within a component function. Since our component function may be called many times throughout the lifecycle of the component, any variable we declare normally (i.e. with `let myVar = ...`) will get reset. With `useState`, React can remember a **state variable** for us, making sure it gets passed into our component instance correctly.

## API

`useState` takes in an initial state as an argument and returns an array containing two elements: the current state, and a function which we can call to set a new state value.

> Notice, in the code when we call `setDiceRoll`, we are not pushing the integer returned from `randomDiceRoll()` into the `diceRolls` array. Instead, we are returning a new array that contains the destructured `diceRolls` array and the newly randomized dice roll.

<Example code={useStateArray} />

## Updating mutable state values

Note how when we call `setDiceRoll`, we're not pushing the integer returned from `randomDiceRoll()` into the `diceRolls` array. Instead, we return a new array containing the destructured `diceRolls` array and the newly randomized dice roll. Why?

Hooks can tell React to re-run our component function and update the UI. The `useState` hook tells React to re-run our component function whenever we call `setDiceRolls` with a different value. Internally, `useState` then compares the current value of `diceRolls` with the value we passed to `setDiceRolls` using `===`. If we're using a mutable value like an array, and we only change its contents, `useState` won't detect that change and won't tell React to re-run our component function. This will result in our UI displaying old/stale data. To avoid this problem we need to create a new array, so that `useState` will detect that our data changed and display the newest data.
